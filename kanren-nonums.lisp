;; uKanren using pointer equality comparisons only for variables, i.e., not using numbers at all

;; Supporting non-Kanren definitions

; More ergonomic definitions

(define list (lambda args args))
(define defun (macro (name args body) (list define name (list lambda args body))))
(define defmacro (macro (name args body) (list define name (list macro args body))))

; Useful higher order functions

(defun Y (f) (f (lambda args ((Y f) . args))))
(defun curry (f x) (lambda args (f x . args)))

; Standard list operations

(defun pair? (x) (not (atom x)))

(defun assoc (k l)
  (cond ((atom l) ())
	((eq k (car (car l))) (car l))
	(t (assoc k (cdr l)))))

(defun append (a b)
  (cond ((not a) b)
	(t (cons (car a) (append (cdr a) b)))))

(defun map (f l)
  (cond ((not l) ())
	(t (cons (f (car l)) (map f (cdr l))))))

; Quasiquote syntax

(defun cadr (x) (car (cdr x)))
(defun cddr (x) (cdr (cdr x)))

(defmacro ` l
  ((Y (lambda (rec)
	(lambda (l)
	  (cond ((not l) ())
		((atom l) (list quote l))
		((eq ',. (car l)) (cadr l))
		((eq ', (car l)) (list cons (cadr l) (rec (cddr l))))
		((eq ',@ (car l)) (list append (cadr l) (rec (cddr l))))
		(t (list cons (rec (car l)) (rec (cdr l)))))))) l))

; Thunks / lazy evaluation

(defmacro delay (x) (` lambda () , x))
(defmacro force (x) (` , x))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	uKanren
;;

; A logic variable is a pair where the head is the symbol `_` and the tail is anything else
(defun logic-var (x) (cons '_ x))
(defun logic-var? (x) (eq (car x) '_))

; `walk` - gets the binding of a variable `v` by following a chain of substitutions `s`
(defun walk (v s)
  (cond ((not (logic-var? v)) v)
	(t (let ((b (assoc v s)))
	     (cond (b (walk (cdr b) s))
		   (t v))))))

; `occurs?` - checks if a variable `v` already exists within some object `x` in a chain of substitutions `s`
(defun occurs? (v x s)
  (let ((x (walk x s)))
    (cond
      ((logic-var? x) (eq v x))
      ((pair? x)
       (or (occurs? v (car x) s)
	   (occurs? v (cdr x) s)))
      (t ()))))

; `ext-s` - extends a substitution list `s` with a new binding for a variable `v` to something `x`
(defun ext-s (v x s)
  (cond ((occurs? v x s) ()) ; prohibit circularities
	(t (cons (cons v x) s))))

; `unify` - attempts to extend a substitution list `s` to make one structure `a` identical to another `b`
(defun unify (a b s)
  (let ((a (walk a s)) (b (walk b s)))
    (cond
      ((eq a b) s)
      ((logic-var? a) (ext-s a b s))
      ((logic-var? b) (ext-s b a s))
      ((and (pair? a) (pair? b))
       (let ((s1 (unify (car a) (car b) s)))
	 (and s1 (unify (cdr a) (cdr b) s1))))
      (t ()))))

; The empty stream is an empty list
(define mzero ())
; A substitution list can be lifted into a stream by putting it in a list
(defun unit (s) (cons s mzero))
; Streams can also be promises, which are nullary functions that return a stream
(defun promise? (x) (eq (type x) 'lambda))
; The initial state to start evaluating a toplevel goal from is the empty list
(define init-state ())

; `==` - constructs a goal unifying a and b
; Note: A goal is a function from a substitution list to a stream of other valid substitution lists
; A goal "succeeds" (or "holds") if it returns a stream of one or more (modified) substitution lists and "fails" otherwise.
(defun == (a b)
  (lambda (s)
    (let ((s1 (unify a b s)))
      (cond (s1 (unit s1))
	    (t mzero)))))

; `call/fresh` - calls a goal with a fresh (unbound) logic variable
(defun call/fresh (f) (f (logic-var ())))

; `disj2` - constructs a goal which forms a logical disjunction by combining the streams generated by two other goals, `g1` and `g2`, upon succeeding
(defun disj2 (g1 g2)
  (lambda (s)
    (mplus (g1 s) (g2 s))))

; `conj2` - constructs a goal which forms a logical conjunction by running one goal, `g2`, on the stream of results from another goal, `g1`
(defun conj2 (g1 g2)
  (lambda (s)
    (bind g2 (g1 s))))

; `mplus` - combines two streams of results, `s1` and `s2`, by performing a list append or executing promises as applicable
(defun mplus (s1 s2)
  (cond ((not s1) s2)
	((promise? s1) (delay (mplus s2 (force s1)))) ; continue from s2 in case s1 is infinite
	(t (cons (car s1) (mplus (cdr s1) s2)))))

; `bind` - executes a goal `g` on each element of a stream `s`, forming another stream of substitutions returned by the goal succeeding
(defun bind (g s)
  (cond ((not s) ())
	((promise? s) (delay (bind g (force s))))
	(t (mplus (g (car s)) (bind g (cdr s))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (End of uKanren core)
;;

; `recons` - reconstruct a (flat) list using a given function
(defun recons (f l)
  (cond ((not l) ())
	(t (f (car l) (recons f (cdr l))))))


;; Easier goal construction via `conde` and `fresh

; Variadic `conj`/`disj` - reconstruct the list of goals by chaining their dyadic forms
(defmacro conj args
  (recons (lambda (a d) (or (and d (` conj2 , a , d)) a)) args))

(defmacro disj args
  (recons (lambda (a d) (or (and d (` disj2 , a , d)) a)) args))

; `conde` - form a disjunction between lists of conjoined goals
(defmacro conde ls
  (let ((do-conj (lambda (l) (` conj ,. l)))
	(do-disj (lambda (l) (` disj ,. l))))
    (do-disj (map do-conj ls))))


; `fresh1` - construct a goal with a single fresh variable
(defmacro fresh1 (arg body)
  (` call/fresh (lambda (, arg) , body)))

; `fresh` - construct a goal with multiple fresh variables by chaining fresh1
(defmacro fresh (args . body)
  (recons (lambda (a d) (` fresh1 , a , (or d (` conj ,. body)))) args))


;; Easier goal definition and execution via `relation` and `run*`

; `take*` - take all elements from a stream and construct a list out of them
(defun take* (s)
  (cond ((promise? s) (take* (force s)))
	((atom s) s)
	(t (cons (car s) (take* (cdr s))))))

; `relation` - shortcut for constructing a goal which is delayed to permit recursion
(defmacro relation (args body)
  (` lambda , args
     (lambda (s)
       (delay (, body s)))))

; `reify` - reconstruct a variable from values in a substitution list
(defun reify (v s)
  (let ((v (walk v s)))
    (cond ((atom v) v)
	  (t (cons (reify (car v) s) (reify (cdr v) s))))))

; `reify-targets` - create logic variables for a list of arguments
(defun reify-targets (args)
  (cond ((not args) ())
	(t (cons (logic-var (car args)) (reify-targets (cdr args))))))

; `run*` - execute a goal with multiple variables from scratch and reify all results
; `run*` - execute a goal `body` with multiple variables `args` from scratch and reify the arguments from every result
(defmacro run* (args body)
  (` let ((targets (reify-targets (quote , args))))
     (map (curry reify targets)
	  (take* (((relation , args , body) . targets) init-state)))))


;; Testing with the canonical example, `appendo`

(define appendo
  (relation (as bs as-bs)
	    (conde ((== as ()) (== bs as-bs))
		   ((fresh (a s s-bs)
			   (== as (cons a s))
			   (== as-bs (cons a s-bs))
			   (appendo s bs s-bs))))))

(run* (a b) (appendo a b '(A B C D E F G)))


;; Finally, giving in and using numbers just to limit the number of results we get

; `take` - take a certain number `n` of elements from a stream `s` and construct a list out of them
(defun take (n s)
  (cond ((= n 0) ())
	((promise? s) (take n (force s)))
	((atom s) s)
	(t (cons (car s) (take (- n 1) (cdr s))))))

; `run` - execute a goal `body` with multiple variables `args` from scratch and reify the arguments from a certain number `n` of the results
(defmacro run (n args body)
  (` let ((targets (reify-targets (quote , args))))
     (map (curry reify targets)
	  (take , n (((relation , args , body) . targets) init-state)))))

;; Testing it on the most general query of `appendo`

(run 3 (a b l) (appendo a b l))
